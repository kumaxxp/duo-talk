<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Duo Talk — Live Runs</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-slate-50 text-slate-900">
    <div class="max-w-7xl mx-auto p-4 space-y-4">
      <header class="flex items-center justify-between">
        <h1 class="text-2xl font-semibold">DUO RUNS</h1>
        <nav class="text-sm text-slate-500">Backend UI — <a class="underline" href="/docs">/docs</a></nav>
      </header>

      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <section class="space-y-3">
          <div class="p-4 bg-white rounded-lg shadow">
            <h2 class="font-medium mb-2">New Run</h2>
            <form id="runForm" class="space-y-2">
              <input class="w-full px-3 py-2 border rounded" name="topic" placeholder="topic" />
              <input class="w-full px-3 py-2 border rounded" name="model" placeholder="model (e.g., gemma3:12b)" />
              <div class="grid grid-cols-3 gap-2">
                <input class="px-3 py-2 border rounded" name="maxTurns" type="number" placeholder="maxTurns" value="8" />
                <input class="px-3 py-2 border rounded" name="seed" type="number" placeholder="seed (optional)" />
                <label class="flex items-center gap-2 text-sm"><input type="checkbox" name="noRag" /> noRag</label>
              </div>
              <button class="px-3 py-2 bg-slate-900 text-white rounded hover:bg-slate-800" type="submit">Start</button>
            </form>
          </div>

          <div class="p-4 bg-white rounded-lg shadow">
            <h2 class="font-medium mb-2">Runs</h2>
            <div id="runs" class="space-y-1 text-sm max-h-64 overflow-auto md:max-h-80"></div>
          </div>

          <div class="p-4 bg-white rounded-lg shadow">
            <h2 class="font-medium mb-2">Filters</h2>
            <div class="flex flex-wrap gap-2 text-sm">
              <label class="flex items-center gap-1"><input type="checkbox" id="fA" checked /> Speaker A</label>
              <label class="flex items-center gap-1"><input type="checkbox" id="fB" checked /> Speaker B</label>
              <label class="flex items-center gap-1"><input type="checkbox" id="fBAN" checked /> BANter</label>
              <label class="flex items-center gap-1"><input type="checkbox" id="fPIV" checked /> PIVOT</label>
              <label class="flex items-center gap-1"><input type="checkbox" id="fPAY" checked /> PAYOFF</label>
            </div>
          </div>

          <div class="p-4 bg-white rounded-lg shadow">
            <h2 class="font-medium mb-2">RAG Panel</h2>
            <div id="ragPanel" class="grid grid-cols-1 gap-3"></div>
          </div>
        </section>

        <section class="lg:col-span-2 space-y-3">
          <div class="p-4 bg-white rounded-lg shadow">
            <div class="flex items-center justify-between mb-2">
              <h2 class="font-medium">Timeline</h2>
              <div id="spark" class="h-8 w-48"></div>
            </div>
            <div id="timeline" class="space-y-3"></div>
          </div>
        </section>
        
      </div>
    </div>

    <script>
      const API = '';
      let currentRID = null;
      let es = null;
      const state = { rag: {}, speaks: {}, directors: {}, selectedTurn: null };

      function tkn(s){ return (s||'').match(/[A-Za-z0-9ぁ-んァ-ン一-龯]{2,}/g) || []; }
      function grams(s,n=3){ const c=(s||'').replace(/\s+/g,''); return new Set(Array.from({length: Math.max(0,c.length-n+1)}, (_,i)=>c.slice(i,i+n))); }
      function cov(sn,ut){
        const A=new Set(tkn(sn)), B=new Set(tkn(ut)); const tok = A.size? [...A].filter(x=>B.has(x)).length/A.size:0;
        const g1=grams(sn,3), g2=grams(ut,3); const cg = g1.size? [...g1].filter(x=>g2.has(x)).length/g1.size:0;
        return Math.max(tok,cg);
      }

      function badge(beat){ const m={BANter:'bg-gray-200 text-gray-800', PIVOT:'bg-blue-200 text-blue-800', PAYOFF:'bg-purple-200 text-purple-800'}; return `<span class="px-2 py-0.5 rounded ${m[beat]||'bg-slate-200'}">${beat||'-'}</span>` }
      function progress(p, title){ const w=Math.round((p||0)*100); const cls=(p<0.10)?'bg-slate-300':(p<0.20)?'bg-amber-400':'bg-emerald-500'; return `<div class="w-full bg-slate-100 rounded h-2" title="${title||''}"><div class="h-2 rounded ${cls}" style="width:${w}%"></div></div>` }

      function renderRuns(list){
        const el = document.getElementById('runs');
        el.innerHTML = '';
        list.forEach(r=>{
          const a = document.createElement('button');
          a.className = 'w-full text-left px-2 py-1 rounded hover:bg-slate-100';
          a.textContent = `${r.run_id.slice(0,8)}…  ${r.topic||''}`;
          a.onclick = ()=> connect(r.run_id);
          el.appendChild(a);
        })
      }

      function render(){
        const tl = document.getElementById('timeline');
        tl.innerHTML = '';
        const fA=document.getElementById('fA').checked, fB=document.getElementById('fB').checked;
        const fBAN=document.getElementById('fBAN').checked, fPIV=document.getElementById('fPIV').checked, fPAY=document.getElementById('fPAY').checked;
        const turns = Object.keys(state.speaks).map(Number).sort((a,b)=>a-b);
        // sparkline
        try { drawSpark(turns); } catch(e){}
        turns.forEach(turn=>{
          const sp = state.speaks[turn]||{}; const dr = state.directors[turn]||{}; const rag = state.rag[turn]||{};
          const speaker=sp.speaker; const beat=dr.beat;
          if((speaker==='A'&&!fA)||(speaker==='B'&&!fB)) return;
          if((beat==='BANter'&&!fBAN)||(beat==='PIVOT'&&!fPIV)||(beat==='PAYOFF'&&!fPAY)) return;
          const canonPv=rag.canon?.preview||''; const lorePv=rag.lore?.preview||''; const pattPv=rag.pattern?.preview||'';
          const cCanon=cov(canonPv, sp.text||''); const cLore=cov(lorePv, sp.text||''); const cPatt=cov(pattPv, sp.text||'');
          const c = Math.max(cCanon,cLore,cPatt);
          const tip = `c=${cCanon.toFixed(2)} l=${cLore.toFixed(2)} p=${cPatt.toFixed(2)}`;
          const card = document.createElement('div');
          card.className = 'border rounded p-3';
          card.id = `turn-${turn}`;
          const charIcon = speaker === 'A' ? '/icon/yana_face.png' : '/icon/ayu_face.png';
          const charName = speaker === 'A' ? 'やな' : 'あゆ';
          const charColor = speaker === 'A' ? 'bg-rose-500' : 'bg-sky-500';
          card.innerHTML = `
            <div class="flex items-center justify-between text-sm">
              <div class="flex items-center gap-2"><span class="font-mono">Turn ${turn}</span><img src="${charIcon}" alt="${charName}" class="w-6 h-6 rounded-full object-cover" onerror="this.style.display='none'"><span class="px-1.5 py-0.5 rounded ${charColor} text-white text-xs">${charName}</span>${badge(beat)}</div>
              <div class="text-slate-400">${dr.cut_cue? 'TAG' : ''}</div>
            </div>
            <div class="mt-2 whitespace-pre-wrap leading-relaxed">${(sp.text||'').replace(/</g,'&lt;')}</div>
            <div class="mt-3 flex items-center gap-2">${progress(c, tip)}<span class="text-xs text-slate-500" title="${tip}">${Math.round(c*100)}%</span><span class="text-emerald-500 text-xs" id="unread-${turn}" style="opacity:0">●</span></div>
          `;
          card.onclick = ()=> { state.selectedTurn=turn; renderRag(turn); };
          tl.appendChild(card);
        })
        if (state.selectedTurn) renderRag(state.selectedTurn);
      }

      function renderRag(turn){
        const host = document.getElementById('ragPanel');
        host.innerHTML='';
        const r = state.rag[turn]||{}; const dr=state.directors[turn]||{};
        const items = [ ['canon', r.canon], ['lore', r.lore], ['pattern', r.pattern] ];
        if(dr.beat==='PAYOFF') items.sort((a,b)=> (a[0]==='pattern'?-1:1));
        items.forEach(([k,v])=>{
          const div = document.createElement('div');
          const hi = (dr.beat==='PAYOFF' && k==='pattern');
          div.className = `border rounded p-3 ${hi?'ring-2 ring-violet-400 bg-violet-50':''}`;
          div.innerHTML = `<div class="text-sm mb-1"><span class="px-2 py-0.5 rounded bg-slate-100 font-medium">${k}</span></div><div class="text-sm text-slate-700" title="${v?.path||''}">${(v?.preview||'-')}</div><div class="text-xs text-slate-400 mt-1">${v?.path||''}</div>`
          host.appendChild(div);
        })
      }

      function drawSpark(turns){
        const el = document.getElementById('spark'); if(!el) return;
        const vals = turns.map(t=>{ const sp=state.speaks[t]||{}; const rag=state.rag[t]||{}; return Math.max(cov(rag.canon?.preview||'', sp.text||''), cov(rag.lore?.preview||'', sp.text||''), cov(rag.pattern?.preview||'', sp.text||'')); });
        if (!vals.length){ el.innerHTML=''; return; }
        const W=180,H=24; const max=Math.max(...vals,0.001);
        const pts = vals.map((v,i)=> [i*(W/(vals.length-1||1)), H - (v/max)*H]);
        const d = pts.map((p,i)=> (i?'L':'M')+p[0].toFixed(1)+','+p[1].toFixed(1)).join(' ');
        el.innerHTML = `<svg width="${W}" height="${H}"><path d="${d}" fill="none" stroke="#10b981" stroke-width="2" /></svg>`;
      }

      async function fetchRuns(){
        const r = await fetch(API + '/api/run/list'); const js = await r.json(); renderRuns(js);
        if(!currentRID && js[0]) connect(js[0].run_id);
      }

        // Improved stream reader function replacing connect() for GET stream
        // For 'POST' based unification, we use the submit handler above.
        // But for clicking on history list, we still need GET stream.
        // Note: Unified API does not have GET stream for history re-connection yet in this plan? 
        // api_unified.py only has POST /run/start. 
        // To read PAST history, we might need a separate endpoint or just use the old log file reader?
        // api_server.py still mounts static files and API. api_server.py removed /api/run/start but kept /api/run/stream (WAIT)
        // I checked api_server.py, I only removed start endpoints. 
        // The SSE `stream_run_events` endpoint in api_server.py (lines ~160) was NOT removed.
        // So clicking history items still works with existing connect()!
        // So we only need to update the POST submission.

      document.getElementById('runForm').addEventListener('submit', async (ev)=>{
        ev.preventDefault();
        const fd = new FormData(ev.target);
        
        // Disconnect previous stream
        if(es) { es.close(); es=null; }
        state.rag={}; state.speaks={}; state.directors={}; 
        render();

        const body = { 
            text: fd.get('topic') || '', 
            model: fd.get('model') || '', 
            maxTurns: Number(fd.get('maxTurns')||8), 
            seed: Number(fd.get('seed')||0), 
            noRag: !!fd.get('noRag') 
        };

        try {
            const response = await fetch(API + '/api/unified/run/start', {
                method: 'POST', 
                headers: {'Content-Type': 'application/json'}, 
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const err = await response.json().catch(()=>({}));
                alert("Error: " + (err.error || response.statusText));
                return;
            }

            // Stream handler
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            // Handle stream
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop(); // Keep last incomplete line

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const d = JSON.parse(line.slice(6));
                            
                            // Capture run_id on first event
                            if (d.run_id && d.run_id !== currentRID) {
                                currentRID = d.run_id;
                                console.log("New Run ID:", currentRID);
                            }

                            // Event dispatch
                            if (d.speaker) { // Speak event
                                state.speaks[d.turn] = d; 
                                render();
                                const el=document.getElementById(`turn-${d.turn}`); 
                                if(el){ 
                                    el.scrollIntoView({behavior:'smooth', block:'nearest'}); 
                                    const dot=document.getElementById(`unread-${d.turn}`); 
                                    if(dot){ dot.style.opacity='1'; setTimeout(()=>dot.style.opacity='0', 2000);} 
                                } 
                            } else if (d.beat) { // Director event (mapped from backend mismatch if any, but usually separate)
                                // In unified pipeline, director info might be inside speak event or separate?
                                // Based on api_unified logic, events are yielded as they come. 
                                // Usage of 'director' event depends on pipeline implementation. 
                                // Assuming 'director' event key exists.
                            }

                            // Compatibility mapping
                            if (line.includes('"event": "director"')) {
                                // Need to parse 'event: type' line logic properly or rely on JSON payload
                                // Simple parser above assumes 'data: json'. 
                                // But real SSE has 'event: name'. 
                                // Let's improve parser below.
                            }
                        } catch(e) {}
                    }
                    if (line.startsWith('event: ')) {
                        // Very simple state machine could be better, but for now just rely on data payload if it contains type
                        // Or we can parse properly.
                    }
                }
            }
        } catch (e) {
            console.error(e);
            alert("Stream error");
        }
        
        setTimeout(fetchRuns, 800);
      });

      function syncFiltersToURL(){
        const p=new URLSearchParams(location.search);
        p.set('speaker', [document.getElementById('fA').checked?'A':null, document.getElementById('fB').checked?'B':null].filter(Boolean).join(','));
        p.set('beat', [document.getElementById('fBAN').checked?'BANter':null, document.getElementById('fPIV').checked?'PIVOT':null, document.getElementById('fPAY').checked?'PAYOFF':null].filter(Boolean).join(','));
        history.replaceState(null,'', location.pathname + '?' + p.toString());
      }
      function loadFiltersFromURL(){
        const p=new URLSearchParams(location.search);
        const sp=(p.get('speaker')||'A,B').split(',');
        document.getElementById('fA').checked=sp.includes('A');
        document.getElementById('fB').checked=sp.includes('B');
        const bt=(p.get('beat')||'BANter,PIVOT,PAYOFF').split(',');
        document.getElementById('fBAN').checked=bt.includes('BANter');
        document.getElementById('fPIV').checked=bt.includes('PIVOT');
        document.getElementById('fPAY').checked=bt.includes('PAYOFF');
      }
      ;['fA','fB','fBAN','fPIV','fPAY'].forEach(id=> document.getElementById(id).addEventListener('change', ()=>{ syncFiltersToURL(); render(); }));

      loadFiltersFromURL();
      fetchRuns();
      setInterval(fetchRuns, 5000);
    </script>
  </body>
  </html>
